# Notes

Програмата очаква два реда - regex и string за парсене
Output-а е като по условие - `yes, start, length` при успех и `no` при неуспех (невалиден regex или не-match-ващ string)

Програмата поддържа следните regex-и:
- `.` - каквото и да е
- `a` - буквата/литерала `a` (аналогично каквато и да е друга буква)
- `_?` - опционален прост regex (точка или литерал)
- `_*` - клини на прост regex (точка или литерал)
- `(_)?` - опционален сложен regex (пълна рекурсия)
- `(_)*` - клини на сложен regex (пълна рекурсия)
- `__` - конкатенация на сложни regex-и (пълна рекурсия)

NOTE: много лесно могат да се добавят още правила

Програмата е написана на езикът Haskell, и използва бибиотеката `Megaparsec`, която е библиотека за (т. нар.) Parser комбинатори.
Тя ни позволява от малки парсъри ("парсни една буква" -> `char`) да правим по-големи, комбинирайки малките (`many` "парсни една буква" == "парсни много букви" -> `string`)

Първо parse-ваме regex-а от входа, че да конструираме нещо като AST, което дърво го превръщаме/компилираме в парсър за низове, който пускаме върху всички инфикси на подаденият тестов низ.
